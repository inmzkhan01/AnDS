package algorithms.exercises;

public class UnionFind {

    /**
     * Social network connectivity. Given a social network containing nn members and a log file containing mm timestamps
     * at which times pairs of members formed friendships, design an algorithm to determine the earliest time at which
     * all members are connected (i.e., every member is a friend of a friend of a friend ... of a friend).
     * Assume that the log file is sorted by timestamp and that friendship is an equivalence relation.
     * The running time of your algorithm should be m \log nmlogn or better and use extra space proportional to nn
     */


    /**
     * Union-find with specific canonical element. Add a method ðšðš’ðš—ðš() to the union-find data type so that ðšðš’ðš—ðš(ðš’) returns
     * the largest element in the connected component containing ii. The operations, ðšžðš—ðš’ðš˜ðš—(), ðšŒðš˜ðš—ðš—ðšŽðšŒðšðšŽðš(), and ðšðš’ðš—ðš() should
     * all take logarithmic time or better
     */


    /**
     * Successor with delete. Given a set of nn integers S = {0,1,...,nâˆ’1} and a sequence of requests of the following form:
     *
     * Remove x from S
     * Find the successor of x: the smallest y in S such that y >= x.
     * design a data type so that all operations (except construction) take logarithmic time or better in the worst case.
     */
}
