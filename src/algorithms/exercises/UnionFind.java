package algorithms.exercises;

public class UnionFind {

    /**
     * Social network connectivity. Given a social network containing nn members and a log file containing mm timestamps
     * at which times pairs of members formed friendships, design an algorithm to determine the earliest time at which
     * all members are connected (i.e., every member is a friend of a friend of a friend ... of a friend).
     * Assume that the log file is sorted by timestamp and that friendship is an equivalence relation.
     * The running time of your algorithm should be m \log nmlogn or better and use extra space proportional to nn
     */


    /**
     * Union-find with specific canonical element. Add a method 𝚏𝚒𝚗𝚍() to the union-find data type so that 𝚏𝚒𝚗𝚍(𝚒) returns
     * the largest element in the connected component containing ii. The operations, 𝚞𝚗𝚒𝚘𝚗(), 𝚌𝚘𝚗𝚗𝚎𝚌𝚝𝚎𝚍(), and 𝚏𝚒𝚗𝚍() should
     * all take logarithmic time or better
     */


    /**
     * Successor with delete. Given a set of nn integers S = {0,1,...,n−1} and a sequence of requests of the following form:
     *
     * Remove x from S
     * Find the successor of x: the smallest y in S such that y >= x.
     * design a data type so that all operations (except construction) take logarithmic time or better in the worst case.
     */
}
